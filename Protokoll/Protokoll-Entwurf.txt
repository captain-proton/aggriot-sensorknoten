Nachrichtencodierung Little Endian. (Bei x86/64 und ARM sollte das am einfachsten sein).

Nachrichtenaufbau:
- StartByte 1 Byte
- Flag 1 Byte
	- Version 2 Bit		(Bits 6/7 = 0b00)
	- IsAck 1 Bit		(Bit 5, ACK=1, Request=0)
	- Up/Downstream 1 Bit	(Bit 4, Sensor->Aggr=0, Aggr->Sensor=1)
	- Reserved 4 Bit	(Bits 0-3, alle 0)
- Payload-Länge 1 Byte
- Sensor-Adresse (je nach Up/Downstream) 4 Byte [wollen wir dafür 32 Bit opfern?]
- Sequenznummer 4 Byte [136 Jahre bei einer Nachricht pro Sekunde]
- Encrypted {
	Payload, min 4 Byte {
	 - Payload-Typ		1 Byte
	 - Payload-Data		n ≥ 3 Byte
	}
    - Payload-CRC			32 Bit (Payload-Typ und Payload-Data)
}
- CRC16 2 Byte (Startbyte bis Payload-CRC inklusive)

-----

- Payload {
    - Temperatur        2 Byte (normalisiert [0-5000])
    - Luftfeuchtigkeit  2 Byte (normalisiert [0-10000])
    - Staub             4 Byte (normalisiert [0-3000000])
    - Licht             2 Byte ([0-800])
    - Lichtwiderstand   2 Byte
    - Lautstärke        2 Byte ([20-400])
    - Normalisierer     1 Byte ([100])
}

One-Time-Pad für Payload-Verschlüsselung pro 16-Byte-Datenblock der Nachricht:
Upstream (S zu A):   aes128(psk, Sensoradresse (4 Byte) | Sequenznummer (4 Byte) | Block-NR + 128 (1 Byte) )
Downstream (A zu S): aes128(psk, Sensoradresse (4 Byte) | Sequenznummer (4 Byte) | Block-NR (1 Byte) )

-> Jede Seite speichert nur die letzte benutzte Sequenznummer. Wenn eine Seite eine zu kleine Sequenznummer
verwendet, die aber gültig ist (Signatur okay, NUR Sequenznummer zu niedrig) antwortet er mit Payload-Typ 255
und benutzt _seine_ aktuelle Sequenznummer. Die Gegenseite updated dann ihre eigene Sequenznummer auf den
erforderlichen Stand und die Kommunikation wird erneut probiert.

[-> Wenn die empfangene Sequenznummer zu weit vorne ist, wird die eigene Sequenznummer dahin vorgezogen.]

Wenn keine Daten (oder zu wenige Daten) verschickt werden, wird am Ende mit 0-Bytes auf 4 Byte gepadded. Auf
jeden Fall wird in Payload-Länge die tatsächliche Länge der Daten [ohne Padding] angegeben. Das dient dazu,
dass die integrität der Daten überprüft werden kann (wir brauchen zuminest ein paar Byte dafür).
Dies dient ebenfalls als Signatur der ACKs.

Problem:
- Wir können jedes Paket mit 2^32 Sendeversuchen gültig bekommen. Die Daten sind dann halt ziemlich unsinnig. Um
das sicherer zu machen müsste man die Payload-CRC vergrößern. Jedes Paket hat eine Mindestlänge von 23 Byte.
Bei 50 kBit/sec schaffen wir 271 Paket pro Sekunde (maximal, da der Zigbee-Header etc noch dazu kommt).
Wir brauchen 2^31 Versuche zum imitieren eines Pakets. Das dauert 91 Tage. Im besten Fall ist allerdings die
Sequenznummer dann durch neue Nachrichten (mindestens eine Nachricht pro Tag?) eh durch..
Damit hätten wir allerdings noch keinen zu einem ACK passenden gültigen Content.
